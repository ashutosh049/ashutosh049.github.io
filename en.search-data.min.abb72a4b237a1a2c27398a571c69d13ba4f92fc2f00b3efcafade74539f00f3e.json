[{"id":0,"href":"/docs/leetcode/binary-tree/maximum-depth-of-binary-tree/","title":"104. Maximum Depth of Binary Tree","section":"Binary Tree","content":"104. Maximum Depth of Binary Tree\r#\r\rProblem Statement\r#\r\rGiven the root of a binary tree, return its maximum depth.\n A binary tree\u0026rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n Example 1:\n (3)\r/ \\\r(9) (20)\r/ \\\r(15) (7) Input: root = [3,9,20,null,null,15,7] Output: 3\nThe calling function\r#\r\r/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution {  public int maxDepth(TreeNode root) {  //return maxDepth_Recursive(root);  //return maxDepth_Iterative_BFS(root);  return maxDepth_usingHeightVariable(root);   } } Recursive traversal\r#\r\r private int maxDepth_Recursive(TreeNode root){  if(root == null) return 0;  return Math.max(maxDepth(root.left), maxDepth(root.right)) +1;  } Iterative BFS\r#\r\rWe can use BFS to get the highest level(deepest node). Implement BFS, return the size of the List of level nodes.\nCheck this question for more into on 102. Binary Tree Level Order Traversal\nprivate int maxDepth_Iterative_BFS(TreeNode root){ \t\tList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; resultList = new ArrayList\u0026lt;\u0026gt;(); \t\tif(root == null) return 0; \t\tTreeNode curr = root; \t\tQueue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); \t\tq.offer(curr); \t\twhile(!q.isEmpty()){ \tint qSize = q.size(); \tList\u0026lt;Integer\u0026gt; subList = new ArrayList\u0026lt;\u0026gt;(); \t\tfor(int i=0; i\u0026lt; qSize; i++){ \tcurr = q.poll(); \t\tsubList.add(curr.val); \t\tif(curr.left != null){ \tq.offer(curr.left); \t} \t\tif(curr.right != null){ \tq.offer(curr.right); \t} \t} \t//add to main list \tresultList.add(subList); \t\t} \t\treturn resultList.size(); \t} Iterative traversal using height variable\r#\r\rprivate int maxDepth_usingHeightVariable(TreeNode root){  \tif(root == null) return 0; \t\tQueue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); \t\tq.offer(root); \tint maxDepth = 0; \t\twhile(!q.isEmpty()){ \t\tmaxDepth++; \tint i = q.size(); \twhile(i-- \u0026gt; 0){ \t\tTreeNode curr = q.poll();  \tif(curr.left != null){ \tq.offer(curr.left); \t}  \tif(curr.right != null){ \tq.offer(curr.right); \t} \t} \t\t} \treturn maxDepth; }  Time Complexity for all the 3 way : O(n) Space Complexity for all the 3 way : O(n)\n Related problems\r#\r\r \r102. Binary Tree Level Order Traversal \r987. Vertical Order Traversal of a Binary Tree \r199. Binary Tree Right Side View \r107. Binary Tree Level Order Traversal II \r94. Binary Tree Inorder Traversal  "},{"id":1,"href":"/docs/leetcode/binary-tree/lowest-common-ancestor-of-a-binary-tree/","title":"236. Lowest Common Ancestor of a Binary Tree","section":"Binary Tree","content":"236. Lowest Common Ancestor of a Binary Tree\r#\r\r Problem Statement\r#\r\rGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\n  Example 1:\r#\r\rInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3.\nExample 2:\r#\r\rInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n Intuition\r#\r\rWe need to find the common first parent which has both p and q as descendants.\nConsider the following Binary Tree:\nInput: root: [1, 2, 3, 4, null, 5, 6, null, 7, null, 8, 9, 10, null, null, null, null,null, null, 11, 12] p: 8 q : 11\n\r We can follow the recursive pre-order dfs traversal and go on comparing the current node with p and q.  if(root == null ){  return null; }  For each/any given node(root), check:  If root is null, then we return null. If the one of the nodes among p and q is root itself? It means we found a match and in that case, we need to return that node, the matched root.    So for this we can compare the the root with both p and q.\nif(root == p || root == q){  return root; }   If any of the target nodes p/q does not exist in left child, it will be null. And similarly for right child, it will be null.\n  Once a match is found in either left or right subtree, it is returned back(upward) to the recursive call and then compared with counter part (left or right value). If both the values are found, let say p is found in left subtree and q found in the right subtree, then the current root, parent of left and right is returned as lca.\n  If none found, null will be returned.\n  \r  Follow the blue arrows, when 8 is found(from lca(root.right, 8, 11) of root node 5), it is compared with left child null and 8 is returned from the call stack of root 5.\n  Similarly, node 11 gets returned as a result of recursive call from root 3.\n  Finally, in the call stack of root node 3, left node is 8 and right node is 11. These 2 values are compared and since both are present(not null), current root (3) is returned which returned back till Tree root 1.\n   Complexity Analysis\r#\r\rTime complexity: O(N), where N is the number of nodes in the binary tree. In the worst case(left skewed or right skewed) we might be visiting all the nodes of the binary tree.\nSpace complexity: O(N). This is because the maximum amount of space utilized by the recursion stack would be N since the height of a skewed binary tree could be N.\n program\r#\r\rclass Solution {  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {   if(root == null){  return null;  }   if( root == p || root == q){  return root;  }   TreeNode lNode = lowestCommonAncestor(root.left, p, q);  TreeNode rNode = lowestCommonAncestor(root.right, p, q);   if(lNode == null)  return rNode;   if(rNode == null)  return lNode;   return root;  } } Test cases\r#\r\r[3,5,1,6,2,0,8,null,null,7,4] 5 1 [3,5,1,6,2,0,8,null,null,7,4] 5 4 [1,2] 1 2  Related problems\r#\r\r \rLowest Common Ancestor of a Binary Tree II \rLowest Common Ancestor of a Binary Tree III \rLowest Common Ancestor of a Binary Tree IV   PS: Stay tuned for more such problem explanation and approaches\nProblem Credit : leetcode.com\n"},{"id":2,"href":"/docs/leetcode/binary-tree/binary-tree-paths/","title":"257. Binary Tree Paths","section":"Binary Tree","content":""}]