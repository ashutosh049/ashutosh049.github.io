<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>µicrolean</title>
    <link>https://ashutosh049.github.io/leetcode/binary-tree/</link>
    <description>Recent content on µicrolean</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://ashutosh049.github.io/leetcode/binary-tree/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>104. Maximum Depth of Binary Tree</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/maximum-depth-of-binary-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/maximum-depth-of-binary-tree/</guid>
      <description>104. Maximum Depth of Binary Tree# Problem#Given the root of a binary tree, return its maximum depth.
 A binary tree&amp;rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
 Example#Example 1:# (3)/ \(9) (20)/ \(15) (7) Input: root = [3,9,20,null,null,15,7] Output: 3</description>
    </item>
    
    <item>
      <title>110. Balanced Binary Tree</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/balanced_binary_tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/balanced_binary_tree/</guid>
      <description>110. Balanced Binary TreeEasyGiven a binary tree, determine if it is height-balanced.
For this problem, a height-balanced binary tree is defined as:
a binary tree in which the left and right subtrees of every node differ in height by no more than 1.
&amp;nbsp;
Example 1:
Input: root = [3,9,20,null,null,15,7]Output: trueExample 2:
Input: root = [1,2,2,3,3,null,null,4,4]Output: falseExample 3:
Input: root = []Output: true&amp;nbsp;</description>
    </item>
    
    <item>
      <title>144. Binary Tree Preorder Traversal</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/144-binary-tree-preorder-traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/144-binary-tree-preorder-traversal/</guid>
      <description>144. Binary Tree Preorder Traversal# Problem#Given the root of a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
Example#Example 1:#Input: root = [1,null,2,3]
Output: [1,2,3]
Constraints# The number of nodes in the tree is in the range [0, 100]. 100 &amp;lt;= Node.val &amp;lt;= 100  Follow up#Recursive solution is trivial, could you do it iteratively?</description>
    </item>
    
    <item>
      <title>173. Binary Search Tree Iterator</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/binary_search_tree_iterator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/binary_search_tree_iterator/</guid>
      <description>173. Binary Search Tree IteratorMediumImplement the BSTIterator class that represents an iterator overthe in-order traversal of a binary search tree (BST):
BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.</description>
    </item>
    
    <item>
      <title>236. Lowest Common Ancestor of a Binary Tree</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>236. Lowest Common Ancestor of a Binary Tree# Problem#Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
 According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).</description>
    </item>
    
    <item>
      <title>257. Binary Tree Paths</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/binary-tree-paths/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/binary-tree-paths/</guid>
      <description>257. Binary Tree PathsGiven the root of a binary tree, return all root-to-leaf pathsin any order.
A leaf is a node with no children.
&amp;nbsp;
Example 1:
Input: root = [1,2,3,null,5]Output: [&#34;1-&amp;gt;2-&amp;gt;5&#34;,&#34;1-&amp;gt;3&#34;]Example 2:
Input: root = [1]Output: [&#34;1&#34;]&amp;nbsp;
Constraints:
The number of nodes in the tree is in the range [1, 100].-100 &amp;lt;= Node.val &amp;lt;= 100program#Javaclass Solution {  List&amp;lt;String&amp;gt; res;  public List&amp;lt;String&amp;gt; binaryTreePaths(TreeNode root) {   //return binaryTreePaths_dfs_iterative(root);   this.</description>
    </item>
    
    <item>
      <title>704. Binary Search</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/binary_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/binary_search/</guid>
      <description>704. Binary SearchEasyGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
You must write an algorithm with O(log n) runtime complexity.
&amp;nbsp;
Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4Example 2:</description>
    </item>
    
    <item>
      <title>968. Binary Tree Cameras</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/binary_tree_cameras/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/binary_tree_cameras/</guid>
      <description>968. Binary Tree Cameras# Problem#You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.
Return the minimum number of cameras needed to monitor all nodes of the tree.
Example#Example 1:#Example 1:
Input: root = [0,0,null,0,0]Output: 1Explanation: One camera is enough to monitor all nodes if placed as shown.</description>
    </item>
    
  </channel>
</rss>
