<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>µicrolean</title>
    <link>https://ashutosh049.github.io/</link>
    <description>Recent content on µicrolean</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://ashutosh049.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://ashutosh049.github.io/leetcode/template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/template/</guid>
      <description>Leetcode Problem# Problem#Example#Example 1:#Constraints#Follow up# Approach and Intuition#1. Naive approach#Time Complexity: \( O(n) \)Space Complexity: \( O(1) \) Complete Solution# </description>
    </item>
    
    <item>
      <title>104. Maximum Depth of Binary Tree</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/maximum-depth-of-binary-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/maximum-depth-of-binary-tree/</guid>
      <description>104. Maximum Depth of Binary Tree# Problem#Given the root of a binary tree, return its maximum depth.
 A binary tree&amp;rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
 Example#Example 1:# (3)/ \(9) (20)/ \(15) (7) Input: root = [3,9,20,null,null,15,7] Output: 3</description>
    </item>
    
    <item>
      <title>110. Balanced Binary Tree</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/balanced_binary_tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/balanced_binary_tree/</guid>
      <description>110. Balanced Binary TreeEasyGiven a binary tree, determine if it is height-balanced.
For this problem, a height-balanced binary tree is defined as:
a binary tree in which the left and right subtrees of every node differ in height by no more than 1.
&amp;nbsp;
Example 1:
Input: root = [3,9,20,null,null,15,7]Output: trueExample 2:
Input: root = [1,2,2,3,3,null,null,4,4]Output: falseExample 3:
Input: root = []Output: true&amp;nbsp;</description>
    </item>
    
    <item>
      <title>144. Binary Tree Preorder Traversal</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/144-binary-tree-preorder-traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/144-binary-tree-preorder-traversal/</guid>
      <description>144. Binary Tree Preorder Traversal# Problem#Given the root of a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
Example#Example 1:#Input: root = [1,null,2,3]
Output: [1,2,3]
Constraints# The number of nodes in the tree is in the range [0, 100]. 100 &amp;lt;= Node.val &amp;lt;= 100  Follow up#Recursive solution is trivial, could you do it iteratively?</description>
    </item>
    
    <item>
      <title>159. Longest Substring with At Most Two Distinct Characters</title>
      <link>https://ashutosh049.github.io/leetcode/arrays-and-string-manipulation/sliding_window/longest-substring-with-at-most-two-distinct-characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/arrays-and-string-manipulation/sliding_window/longest-substring-with-at-most-two-distinct-characters/</guid>
      <description>159. Longest Substring with At Most Two Distinct Characters#</description>
    </item>
    
    <item>
      <title>173. Binary Search Tree Iterator</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/binary_search_tree_iterator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/binary_search_tree_iterator/</guid>
      <description>173. Binary Search Tree IteratorMediumImplement the BSTIterator class that represents an iterator overthe in-order traversal of a binary search tree (BST):
BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.</description>
    </item>
    
    <item>
      <title>191. Number of 1 Bits</title>
      <link>https://ashutosh049.github.io/leetcode/bit-manipulation/number-of-1-bits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/bit-manipulation/number-of-1-bits/</guid>
      <description>191. Number of 1 Bits# Problem#Write a function that takes an unsigned integer and returns the number of &amp;lsquo;1&amp;rsquo; bits it has (also known as the Hamming weight).
Note:
 Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer&amp;rsquo;s internal binary representation is the same, whether it is signed or unsigned.</description>
    </item>
    
    <item>
      <title>236. Lowest Common Ancestor of a Binary Tree</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>236. Lowest Common Ancestor of a Binary Tree# Problem#Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
 According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).</description>
    </item>
    
    <item>
      <title>257. Binary Tree Paths</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/binary-tree-paths/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/binary-tree-paths/</guid>
      <description>257. Binary Tree PathsGiven the root of a binary tree, return all root-to-leaf pathsin any order.
A leaf is a node with no children.
&amp;nbsp;
Example 1:
Input: root = [1,2,3,null,5]Output: [&#34;1-&amp;gt;2-&amp;gt;5&#34;,&#34;1-&amp;gt;3&#34;]Example 2:
Input: root = [1]Output: [&#34;1&#34;]&amp;nbsp;
Constraints:
The number of nodes in the tree is in the range [1, 100].-100 &amp;lt;= Node.val &amp;lt;= 100program#Javaclass Solution {  List&amp;lt;String&amp;gt; res;  public List&amp;lt;String&amp;gt; binaryTreePaths(TreeNode root) {   //return binaryTreePaths_dfs_iterative(root);   this.</description>
    </item>
    
    <item>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link>https://ashutosh049.github.io/leetcode/arrays-and-string-manipulation/sliding_window/longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/arrays-and-string-manipulation/sliding_window/longest-substring-without-repeating-characters/</guid>
      <description>3. Longest Substring Without Repeating Characters#ProblemGiven a string s, find the length of the longest substring without repeating characters.ExampleExample 1:#Input: s= &amp;quot;abcabcbb&amp;quot;
Output: 3
Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3.
Example 2:#Input: s = &amp;quot;bbbbb&amp;quot;
Output: 1
Explanation: The answer is &amp;quot;b&amp;quot;, with the length of 1.
ConstraintsFollow upApproach and Intuition#Brute force#We can determine all possible substring out of given string s and check for valid sub-string(string without repeating characters), and among such such valid sub-strings, we can formulate te largest string.</description>
    </item>
    
    <item>
      <title>704. Binary Search</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/binary_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/binary_search/</guid>
      <description>704. Binary SearchEasyGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
You must write an algorithm with O(log n) runtime complexity.
&amp;nbsp;
Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4Example 2:</description>
    </item>
    
    <item>
      <title>968. Binary Tree Cameras</title>
      <link>https://ashutosh049.github.io/leetcode/binary-tree/binary_tree_cameras/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/binary-tree/binary_tree_cameras/</guid>
      <description>968. Binary Tree Cameras# Problem#You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.
Return the minimum number of cameras needed to monitor all nodes of the tree.
Example#Example 1:#Example 1:
Input: root = [0,0,null,0,0]Output: 1Explanation: One camera is enough to monitor all nodes if placed as shown.</description>
    </item>
    
    <item>
      <title>Quick Select</title>
      <link>https://ashutosh049.github.io/leetcode/sorting/selection-algos/quick-select/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ashutosh049.github.io/leetcode/sorting/selection-algos/quick-select/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
